# Phase 1: Conceptual basics

## Setting the stage
## Crash-course/refresher in an initial teaching-language 
## Programming as structured problem-solving
## Basic math & logic for computing
## Mental model of computing: the computer itself
## Mental model of computing: operating systems
## Functions 1
## Functions 2
## Modeling problems as data: primitive types and arrays
## Modeling problems as data: custom types, structs and classes
## Modeling problems as data: keyed
## Modeling problems as data: sequentially
## Modeling problems as data: hierarchically
## Modeling problems as data: non-linear, networked
## Clean coding
## Unit testing
## Debugging
## State and state management


# Phase 2: Hands-on skills for client and server

## Client language crash course 
## Server language crash course
### Common
### JavaScript (Node)
### Python-specific
### Go-specific
## SQL crash course
## Networking
## Async
## OO for UI coding
## Client platform
## Client framework
## Databases: relational
## Integration testing


# Phase 3: Professional, web-scale team development

## Functional approach
## Refactoring
## Databases: NoSQL
## Cloud computing
## Deployment
## Cloud deployment
## Distributed systems design
## Architectural patterns
## Coding for reliability & observability
## Product design & UX
## Estimation and iterative development



------

* Note: this is arguable, but assuming for now that this training is focusing on client-server development (both browser and native-app clients).

So, not game programming, embedded programming, scientific programming, etc.

The reasoning, such as it is:

* (a) there are a lot more jobs out there for client-server
* (b) we want length to be manageable, and it will bloat if we throw in Unity etc 
* (c) there is enough commonality to the fundamentals that it's still useful for other types of programming

